using System.Text;
using ArchIntel.Analysis;
using ArchIntel.IO;

namespace ArchIntel.Reports;

public static class OutputReadmeReport
{
    public static async Task WriteAsync(
        AnalysisContext context,
        IFileSystem fileSystem,
        string outputDirectory,
        CancellationToken cancellationToken)
    {
        var content = BuildMarkdown(context);
        var path = Path.Combine(outputDirectory, "README.md");
        await fileSystem.WriteAllTextAsync(path, content, cancellationToken);
    }

    private static string BuildMarkdown(AnalysisContext context)
    {
        var builder = new StringBuilder();
        builder.AppendLine("# ArchIntel output");
        builder.AppendLine();
        builder.AppendLine("This folder contains deterministic outputs from the ArchIntel CLI run.");
        builder.AppendLine();
        builder.AppendLine("## Files");
        builder.AppendLine();
        builder.AppendLine("- `scan.json`: configuration receipt for this run (solution path, version, effective config, projects).");
        builder.AppendLine("- `scan_summary.json`: scan counts, method count totals, cache hits/misses, load diagnostics, and timing.");
        builder.AppendLine("- `namespaces.json`: per-project namespace statistics (named types plus declared-public/publicly-reachable/total/internal method counts).");
        builder.AppendLine("- `symbols.json`: symbol index of public types/methods for impact analysis.");
        builder.AppendLine("- `projects.json`: project metadata and dependency graph summary (test projects detected by name or test packages).");
        builder.AppendLine("- `packages.json`: package and framework references per project (from csproj PackageReference/FrameworkReference items).");
        builder.AppendLine("- `insights.json` / `insights.md`: derived architecture insights (fan-in/out leaders, core/risky projects, cycle severity, namespace surface, package drift hotspots).");
        builder.AppendLine("- `*.json` / `*.md`: report-specific outputs (e.g., `impact.json`, `violations.json`, `project_graph.json`).");
        builder.AppendLine();
        builder.AppendLine("## Method counting semantics");
        builder.AppendLine();
        builder.AppendLine("- `DeclaredPublicMethodCount` counts methods declared `public` regardless of containing type visibility.");
        builder.AppendLine("- `PubliclyReachableMethodCount` counts `public` methods only when every containing type in the chain is `public`.");
        builder.AppendLine("- Private or internal types can still declare `public` methods. Those methods are included in declared-public counts but excluded from publicly-reachable counts.");
        builder.AppendLine();
        builder.AppendLine("## `namespaces.json` schema");
        builder.AppendLine();
        builder.AppendLine("Each project entry contains: `ProjectName`, `ProjectId`, `RoslynProjectId`, `ProjectPath`, `Namespaces`.");
        builder.AppendLine("Each namespace entry contains: `Name`, `PublicTypeCount`, `TotalTypeCount`, `DeclaredPublicMethodCount`, `PubliclyReachableMethodCount`, `TotalMethodCount`, `InternalMethodCount`, `TopTypes`.");
        builder.AppendLine("Each top type entry contains: `Name`, `Visibility`, `DeclaredPublicMethodCount`, `PubliclyReachableMethodCount`, `TotalMethodCount`.");
        builder.AppendLine();
        builder.AppendLine("## `scan_summary.json` schema");
        builder.AppendLine();
        builder.AppendLine("- `Counts`: `ProjectCount`, `FailedProjectCount`, `AnalyzedDocuments`.");
        builder.AppendLine("- `MethodCounts`: `DeclaredPublicMethodsTotal`, `PubliclyReachableMethodsTotal`, `TotalMethodsTotal`, `InternalMethodsTotal`.");
        builder.AppendLine("- `CacheHits`, `CacheMisses`, `Durations`, `LoadDiagnostics`.");
        builder.AppendLine();
        builder.AppendLine("## Using with AI tools");
        builder.AppendLine();
        builder.AppendLine("You can copy/paste `scan_summary.json`, `scan.json`, and any report JSON into an AI assistant");
        builder.AppendLine("to get help summarizing architectural hotspots or drafting remediation plans.");
        builder.AppendLine("Always review results before acting on them.");
        builder.AppendLine();
        builder.AppendLine($"Generated by ArchIntel {context.AnalysisVersion}.");
        return builder.ToString();
    }
}
